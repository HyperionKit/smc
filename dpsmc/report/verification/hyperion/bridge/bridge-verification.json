{
  "contractName": "Bridge",
  "contractAddress": "0xfF064Fd496256e84b68dAE2509eDA84a3c235550",
  "sourceCode": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\ncontract Bridge is Ownable, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    event TokenDeposited(address indexed user, address indexed token, uint256 amount, uint256 indexed destinationChainId, address destinationAddress, bytes32 depositId);\n    event TokenWithdrawn(address indexed user, address indexed token, uint256 amount, bytes32 indexed depositId, bytes32 withdrawalId);\n    event RelayerAdded(address indexed relayer);\n    event RelayerRemoved(address indexed relayer);\n    event TokenAdded(address indexed token, string symbol, uint256 chainId);\n    event TokenRemoved(address indexed token, uint256 chainId);\n    event ChainSupported(uint256 indexed chainId, bool supported);\n    event FeeUpdated(uint256 newFee);\n    event TimeoutUpdated(uint256 newTimeout);\n\n    struct Deposit {\n        address user;\n        address token;\n        uint256 amount;\n        uint256 destinationChainId;\n        address destinationAddress;\n        uint256 timestamp;\n        bool withdrawn;\n    }\n\n    struct Withdrawal {\n        address user;\n        address token;\n        uint256 amount;\n        bytes32 depositId;\n        uint256 timestamp;\n        bool processed;\n    }\n\n    struct TokenMapping {\n        string symbol;\n        address tokenAddress;\n        uint256 chainId;\n        uint8 decimals;\n        bool isActive;\n    }\n\n    mapping(address => bool) public relayers;\n    mapping(address => bool) public supportedTokens;\n    mapping(address => string) public tokenSymbols;\n    mapping(uint256 => bool) public supportedChains;\n    mapping(bytes32 => Deposit) public deposits;\n    mapping(bytes32 => Withdrawal) public withdrawals;\n    mapping(bytes32 => bool) public processedWithdrawals;\n\n    // Token mapping state variables\n    mapping(string => mapping(uint256 => address)) public tokenAddresses;\n    mapping(address => string) public addressToSymbol;\n    mapping(string => mapping(uint256 => uint8)) public tokenDecimals;\n    mapping(uint256 => mapping(string => bool)) public activeTokens;\n\n    uint256 public bridgeFee = 0.001 ether;\n    uint256 public withdrawalTimeout = 24 hours;\n    uint256 public depositCount = 0;\n    uint256 public withdrawalCount = 0;\n\n    modifier onlyRelayer() {\n        require(relayers[msg.sender], \"Bridge: caller is not a relayer\");\n        _;\n    }\n\n    modifier validToken(address token) {\n        require(supportedTokens[token], \"Bridge: token not supported\");\n        _;\n    }\n\n    modifier validChain(uint256 chainId) {\n        require(supportedChains[chainId], \"Bridge: chain not supported\");\n        _;\n    }\n\n    constructor(address _owner) Ownable(_owner) {\n        relayers[_owner] = true;\n        emit RelayerAdded(_owner);\n    }\n\n    function deposit(address token, uint256 amount, uint256 destinationChainId, address destinationAddress) external payable nonReentrant whenNotPaused validToken(token) validChain(destinationChainId) {\n        require(amount > 0, \"Bridge: amount must be greater than 0\");\n        require(destinationAddress != address(0), \"Bridge: invalid destination address\");\n        require(msg.value >= bridgeFee, \"Bridge: insufficient bridge fee\");\n\n        string memory symbol = tokenSymbols[token];\n        require(bytes(symbol).length > 0, \"Bridge: token symbol not found\");\n        require(activeTokens[destinationChainId][symbol], \"Bridge: token not active on destination chain\");\n\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        bytes32 depositId = keccak256(abi.encodePacked(msg.sender, token, amount, destinationChainId, destinationAddress, block.timestamp, depositCount));\n        deposits[depositId] = Deposit({user: msg.sender, token: token, amount: amount, destinationChainId: destinationChainId, destinationAddress: destinationAddress, timestamp: block.timestamp, withdrawn: false});\n        depositCount++;\n        emit TokenDeposited(msg.sender, token, amount, destinationChainId, destinationAddress, depositId);\n    }\n\n    function withdraw(address user, address token, uint256 amount, bytes32 depositId, bytes calldata signature) external onlyRelayer nonReentrant whenNotPaused validToken(token) {\n        require(user != address(0), \"Bridge: invalid user address\");\n        require(amount > 0, \"Bridge: amount must be greater than 0\");\n        require(!processedWithdrawals[depositId], \"Bridge: withdrawal already processed\");\n        bytes32 messageHash = keccak256(abi.encodePacked(user, token, amount, depositId));\n        require(_verifySignature(messageHash, signature), \"Bridge: invalid signature\");\n        processedWithdrawals[depositId] = true;\n        bytes32 withdrawalId = keccak256(abi.encodePacked(user, token, amount, depositId, block.timestamp, withdrawalCount));\n        withdrawals[withdrawalId] = Withdrawal({user: user, token: token, amount: amount, depositId: depositId, timestamp: block.timestamp, processed: true});\n        withdrawalCount++;\n        IERC20(token).safeTransfer(user, amount);\n        emit TokenWithdrawn(user, token, amount, depositId, withdrawalId);\n    }\n\n    function _verifySignature(bytes32 messageHash, bytes calldata signature) internal pure returns (bool) {\n        // Simplified signature verification for testing\n        // In production, implement proper ECDSA signature verification\n        return signature.length > 0;\n    }\n\n    function getTokenAddress(string calldata symbol, uint256 chainId) external view returns (address) {\n        return tokenAddresses[symbol][chainId];\n    }\n\n    function getTokenSymbol(address token) external view returns (string memory) {\n        return addressToSymbol[token];\n    }\n\n    function getTokenDecimals(string calldata symbol, uint256 chainId) external view returns (uint8) {\n        return tokenDecimals[symbol][chainId];\n    }\n\n    function isTokenActive(string calldata symbol, uint256 chainId) external view returns (bool) {\n        return activeTokens[chainId][symbol];\n    }\n\n    function getTokenMappings(string calldata symbol) external view returns (TokenMapping[] memory) {\n        uint256 count = 0;\n        uint256[] memory chainIds = new uint256[](10);\n        uint256 chainCount = 0;\n\n        for (uint256 i = 0; i < 1000; i++) {\n            if (supportedChains[i] && activeTokens[i][symbol]) {\n                chainIds[chainCount] = i;\n                chainCount++;\n                count++;\n            }\n        }\n\n        TokenMapping[] memory mappings = new TokenMapping[](count);\n        for (uint256 i = 0; i < count; i++) {\n            uint256 chainId = chainIds[i];\n            mappings[i] = TokenMapping({\n                symbol: symbol,\n                tokenAddress: tokenAddresses[symbol][chainId],\n                chainId: chainId,\n                decimals: tokenDecimals[symbol][chainId],\n                isActive: true\n            });\n        }\n        return mappings;\n    }\n\n    function addToken(address token, string calldata symbol, uint256 chainId, uint8 decimals) external onlyOwner {\n        require(token != address(0), \"Bridge: invalid token address\");\n        require(bytes(symbol).length > 0, \"Bridge: invalid symbol\");\n        require(chainId > 0, \"Bridge: invalid chain ID\");\n\n        supportedTokens[token] = true;\n        tokenSymbols[token] = symbol;\n        addressToSymbol[token] = symbol;\n\n        tokenAddresses[symbol][chainId] = token;\n        tokenDecimals[symbol][chainId] = decimals;\n        activeTokens[chainId][symbol] = true;\n\n        emit TokenAdded(token, symbol, chainId);\n    }\n\n    function removeToken(address token, uint256 chainId) external onlyOwner {\n        require(supportedTokens[token], \"Bridge: token not supported\");\n\n        string memory symbol = tokenSymbols[token];\n\n        supportedTokens[token] = false;\n        delete tokenSymbols[token];\n        delete addressToSymbol[token];\n\n        delete tokenAddresses[symbol][chainId];\n        delete tokenDecimals[symbol][chainId];\n        activeTokens[chainId][symbol] = false;\n\n        emit TokenRemoved(token, chainId);\n    }\n\n    function addRelayer(address relayer) external onlyOwner {\n        require(relayer != address(0), \"Bridge: invalid relayer address\");\n        require(!relayers[relayer], \"Bridge: relayer already exists\");\n        relayers[relayer] = true;\n        emit RelayerAdded(relayer);\n    }\n\n    function removeRelayer(address relayer) external onlyOwner {\n        require(relayers[relayer], \"Bridge: relayer does not exist\");\n        relayers[relayer] = false;\n        emit RelayerRemoved(relayer);\n    }\n\n    function setChainSupport(uint256 chainId, bool supported) external onlyOwner {\n        supportedChains[chainId] = supported;\n        emit ChainSupported(chainId, supported);\n    }\n\n    function setBridgeFee(uint256 newFee) external onlyOwner {\n        bridgeFee = newFee;\n        emit FeeUpdated(newFee);\n    }\n\n    function setWithdrawalTimeout(uint256 newTimeout) external onlyOwner {\n        withdrawalTimeout = newTimeout;\n        emit TimeoutUpdated(newTimeout);\n    }\n\n    function getBridgeStats() external view returns (uint256 totalDeposits, uint256 totalWithdrawals, uint256 currentFee, uint256 currentTimeout) {\n        return (depositCount, withdrawalCount, bridgeFee, withdrawalTimeout);\n    }\n\n    function isWithdrawalProcessed(bytes32 depositId) external view returns (bool) {\n        return processedWithdrawals[depositId];\n    }\n\n    function emergencyWithdraw(address token, address to, uint256 amount) external onlyOwner {\n        require(to != address(0), \"Bridge: invalid recipient\");\n        require(amount > 0, \"Bridge: invalid amount\");\n        IERC20(token).safeTransfer(to, amount);\n    }\n\n    function emergencyWithdrawETH(address to, uint256 amount) external onlyOwner {\n        require(to != address(0), \"Bridge: invalid recipient\");\n        require(amount > 0, \"Bridge: invalid amount\");\n        require(amount <= address(this).balance, \"Bridge: insufficient balance\");\n        (bool success, ) = to.call{value: amount}(\"\");\n        require(success, \"Bridge: ETH transfer failed\");\n    }\n}",
  "constructorArgs": [
    "0xa43B752B6E941263eb5A7E3b96e2e0DEA1a586Ff"
  ],
  "compilerSettings": {
    "version": "0.8.28",
    "settings": {
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "viaIR": true
    }
  },
  "network": "Hyperion Testnet",
  "chainId": 133717,
  "rpcUrl": "https://hyperion-testnet.metisdevops.link",
  "explorerUrl": "https://hyperion-testnet-explorer.metisdevops.link/address/0xfF064Fd496256e84b68dAE2509eDA84a3c235550#code",
  "verificationStatus": "âœ… VERIFIED",
  "timestamp": "2025-08-03T12:00:00.000Z"
} 