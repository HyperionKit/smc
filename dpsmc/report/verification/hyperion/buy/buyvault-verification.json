{
  "contractAddress": "0x0adFd197aAbbC194e8790041290Be57F18d576a3",
  "contractName": "BuyVault",
  "sourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract BuyVault {\r\n    IERC20 public usdc;\r\n    IERC20 public usdt;\r\n    \r\n    uint256 public usdcPrice; // Price in wei (1 METIS = 10^18 wei)\r\n    uint256 public usdtPrice; // Price in wei (1 METIS = 10^18 wei)\r\n    \r\n    address public owner;\r\n    bool public paused;\r\n    \r\n    uint256 public constant PRICE_PRECISION = 1e18;\r\n    uint256 public constant MIN_PURCHASE_AMOUNT = 0.001 ether; // 0.001 METIS minimum\r\n    \r\n    event TokensBought(address indexed buyer, address indexed token, uint256 metisAmount, uint256 tokenAmount);\r\n    event PriceUpdated(address indexed token, uint256 oldPrice, uint256 newPrice);\r\n    event TokensWithdrawn(address indexed token, address indexed to, uint256 amount);\r\n    event METISWithdrawn(address indexed to, uint256 amount);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Paused(address indexed account);\r\n    event Unpaused(address indexed account);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner can call this function\");\r\n        _;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Contract is paused\");\r\n        _;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(!paused, \"Reentrancy not allowed\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address _usdc, \r\n        address _usdt, \r\n        uint256 _usdcPrice, \r\n        uint256 _usdtPrice\r\n    ) {\r\n        require(_usdc != address(0), \"Invalid USDC address\");\r\n        require(_usdt != address(0), \"Invalid USDT address\");\r\n        require(_usdcPrice > 0, \"Invalid USDC price\");\r\n        require(_usdtPrice > 0, \"Invalid USDT price\");\r\n        \r\n        owner = msg.sender;\r\n        usdc = IERC20(_usdc);\r\n        usdt = IERC20(_usdt);\r\n        usdcPrice = _usdcPrice;\r\n        usdtPrice = _usdtPrice;\r\n        paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Buy USDC with METIS\r\n     * @param minTokenAmount Minimum amount of USDC to receive (for slippage protection)\r\n     */\r\n    function buyUSDC(uint256 minTokenAmount) external payable whenNotPaused nonReentrant {\r\n        require(msg.value >= MIN_PURCHASE_AMOUNT, \"Amount below minimum\");\r\n        \r\n        // Convert result to 6 decimals (USDC decimals)\r\n        uint256 tokenAmount = ((msg.value * PRICE_PRECISION) / usdcPrice) / (10**12);\r\n        require(tokenAmount >= minTokenAmount, \"Insufficient token amount\");\r\n        require(tokenAmount > 0, \"Zero token amount\");\r\n        \r\n        // Check contract has enough USDC\r\n        uint256 contractBalance = usdc.balanceOf(address(this));\r\n        require(contractBalance >= tokenAmount, \"Insufficient USDC in contract\");\r\n        \r\n        // Transfer USDC to buyer\r\n        require(usdc.transfer(msg.sender, tokenAmount), \"USDC transfer failed\");\r\n        \r\n        emit TokensBought(msg.sender, address(usdc), msg.value, tokenAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Buy USDT with METIS\r\n     * @param minTokenAmount Minimum amount of USDT to receive (for slippage protection)\r\n     */\r\n    function buyUSDT(uint256 minTokenAmount) external payable whenNotPaused nonReentrant {\r\n        require(msg.value >= MIN_PURCHASE_AMOUNT, \"Amount below minimum\");\r\n        \r\n        // Convert result to 6 decimals (USDT decimals)\r\n        uint256 tokenAmount = ((msg.value * PRICE_PRECISION) / usdtPrice) / (10**12);\r\n        require(tokenAmount >= minTokenAmount, \"Insufficient token amount\");\r\n        require(tokenAmount > 0, \"Zero token amount\");\r\n        \r\n        // Check contract has enough USDT\r\n        uint256 contractBalance = usdt.balanceOf(address(this));\r\n        require(contractBalance >= tokenAmount, \"Insufficient USDT in contract\");\r\n        \r\n        // Transfer USDT to buyer\r\n        require(usdt.transfer(msg.sender, tokenAmount), \"USDT transfer failed\");\r\n        \r\n        emit TokensBought(msg.sender, address(usdt), msg.value, tokenAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate how much USDC you would get for a given amount of METIS\r\n     */\r\n    function getUSDCAmount(uint256 metisAmount) external view returns (uint256) {\r\n        // Convert result to 6 decimals (USDC decimals)\r\n        return ((metisAmount * PRICE_PRECISION) / usdcPrice) / (10**12);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate how much USDT you would get for a given amount of METIS\r\n     */\r\n    function getUSDTAmount(uint256 metisAmount) external view returns (uint256) {\r\n        // Convert result to 6 decimals (USDT decimals)\r\n        return ((metisAmount * PRICE_PRECISION) / usdtPrice) / (10**12);\r\n    }\r\n\r\n    /**\r\n     * @dev Get current prices and contract balances\r\n     */\r\n    function getContractInfo() external view returns (\r\n        uint256 _usdcPrice,\r\n        uint256 _usdtPrice,\r\n        uint256 usdcBalance,\r\n        uint256 usdtBalance,\r\n        uint256 metisBalance\r\n    ) {\r\n        return (\r\n            usdcPrice,\r\n            usdtPrice,\r\n            usdc.balanceOf(address(this)),\r\n            usdt.balanceOf(address(this)),\r\n            address(this).balance\r\n        );\r\n    }\r\n\r\n    // Admin functions\r\n\r\n    /**\r\n     * @dev Set USDC price (only owner)\r\n     */\r\n    function setUSDCPrice(uint256 _usdcPrice) external onlyOwner {\r\n        require(_usdcPrice > 0, \"Invalid price\");\r\n        uint256 oldPrice = usdcPrice;\r\n        usdcPrice = _usdcPrice;\r\n        emit PriceUpdated(address(usdc), oldPrice, _usdcPrice);\r\n    }\r\n\r\n    /**\r\n     * @dev Set USDT price (only owner)\r\n     */\r\n    function setUSDTPrice(uint256 _usdtPrice) external onlyOwner {\r\n        require(_usdtPrice > 0, \"Invalid price\");\r\n        uint256 oldPrice = usdtPrice;\r\n        usdtPrice = _usdtPrice;\r\n        emit PriceUpdated(address(usdt), oldPrice, _usdtPrice);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw tokens from contract (only owner)\r\n     */\r\n    function withdrawTokens(address token, address to, uint256 amount) external onlyOwner {\r\n        require(to != address(0), \"Invalid recipient\");\r\n        require(amount > 0, \"Invalid amount\");\r\n        \r\n        IERC20(token).transfer(to, amount);\r\n        emit TokensWithdrawn(token, to, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw METIS from contract (only owner)\r\n     */\r\n    function withdrawMETIS(address to, uint256 amount) external onlyOwner {\r\n        require(to != address(0), \"Invalid recipient\");\r\n        require(amount > 0, \"Invalid amount\");\r\n        require(amount <= address(this).balance, \"Insufficient balance\");\r\n        \r\n        (bool success, ) = to.call{value: amount}(\"\");\r\n        require(success, \"METIS transfer failed\");\r\n        \r\n        emit METISWithdrawn(to, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer ownership (only owner)\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"Invalid new owner\");\r\n        address oldOwner = owner;\r\n        owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Pause contract (only owner)\r\n     */\r\n    function pause() external onlyOwner {\r\n        paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Unpause contract (only owner)\r\n     */\r\n    function unpause() external onlyOwner {\r\n        paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Emergency function to withdraw all METIS (only owner)\r\n     */\r\n    function emergencyWithdrawMETIS() external onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0, \"No METIS to withdraw\");\r\n        \r\n        (bool success, ) = owner.call{value: balance}(\"\");\r\n        require(success, \"METIS transfer failed\");\r\n        \r\n        emit METISWithdrawn(owner, balance);\r\n    }\r\n\r\n    // Receive function to accept METIS\r\n    receive() external payable {\r\n        // Allow receiving METIS\r\n    }\r\n} ",
  "constructorArgs": [
    "0x31424DB0B7a929283C394b4DA412253Ab6D61682",
    "0x9b52D326D4866055F6c23297656002992e4293FC",
    "10000000000000000",
    "10000000000000000"
  ],
  "compilerSettings": {
    "version": "0.8.28",
    "settings": {
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "viaIR": true
    }
  },
  "network": "Hyperion Testnet",
  "chainId": 133717,
  "rpcUrl": "https://hyperion-testnet.metisdevops.link",
  "timestamp": "2025-08-02T20:37:56.691Z"
}