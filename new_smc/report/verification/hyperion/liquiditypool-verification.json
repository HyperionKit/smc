{
  "contractName": "LiquidityPool",
  "contractAddress": "0x91C39DAA7617C5188d0427Fc82e4006803772B74",
  "sourceCode": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\ncontract LiquidityPool is Ownable, ReentrancyGuard {\n    using Math for uint256;\n\n    struct Pair {\n        address tokenA;\n        address tokenB;\n        uint256 reserveA;\n        uint256 reserveB;\n        uint256 totalLiquidity;\n        bool exists;\n    }\n\n    struct LiquidityPosition {\n        uint256 liquidity;\n        uint256 timestamp;\n    }\n\n    mapping(bytes32 => Pair) public pairs;\n    mapping(bytes32 => mapping(address => LiquidityPosition)) public liquidityPositions;\n    \n    bytes32[] public pairIds;\n    \n    uint256 public constant MINIMUM_LIQUIDITY = 10**3;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n    uint256 public tradingFee = 30; // 0.3%\n    uint256 public constant MAX_FEE = 1000; // 10% max fee\n    bool public paused;\n\n    event PairCreated(\n        address indexed tokenA,\n        address indexed tokenB,\n        bytes32 indexed pairId\n    );\n    \n    event LiquidityAdded(\n        bytes32 indexed pairId,\n        address indexed provider,\n        uint256 amountA,\n        uint256 amountB,\n        uint256 liquidity\n    );\n    \n    event LiquidityRemoved(\n        bytes32 indexed pairId,\n        address indexed provider,\n        uint256 amountA,\n        uint256 amountB,\n        uint256 liquidity\n    );\n    \n    event Swap(\n        bytes32 indexed pairId,\n        address indexed user,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    event TradingFeeUpdated(uint256 oldFee, uint256 newFee);\n\n    constructor() Ownable(msg.sender) {}\n\n    modifier whenNotPaused() {\n        require(!paused, \"Contract is paused\");\n        _;\n    }\n\n    function createPair(address tokenA, address tokenB) external onlyOwner whenNotPaused returns (bytes32) {\n        require(tokenA != tokenB, \"Identical tokens\");\n        require(tokenA != address(0) && tokenB != address(0), \"Zero address\");\n        \n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        bytes32 pairId = keccak256(abi.encodePacked(token0, token1));\n        \n        require(!pairs[pairId].exists, \"Pair already exists\");\n        \n        pairs[pairId] = Pair({\n            tokenA: token0,\n            tokenB: token1,\n            reserveA: 0,\n            reserveB: 0,\n            totalLiquidity: 0,\n            exists: true\n        });\n        \n        pairIds.push(pairId);\n        \n        emit PairCreated(token0, token1, pairId);\n        return pairId;\n    }\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) external nonReentrant whenNotPaused returns (uint256 amountA, uint256 amountB, uint256 liquidity) {\n        bytes32 pairId = getPairId(tokenA, tokenB);\n        require(pairs[pairId].exists, \"Pair does not exist\");\n        \n        Pair storage pair = pairs[pairId];\n        \n        if (pair.reserveA == 0 && pair.reserveB == 0) {\n            // First liquidity provision\n            amountA = amountADesired;\n            amountB = amountBDesired;\n        } else {\n            // Calculate optimal amounts based on current reserves with overflow protection\n            uint256 amountBOptimal;\n            uint256 amountAOptimal;\n            \n            // Safe multiplication and division\n            if (pair.reserveA > 0) {\n                amountBOptimal = (amountADesired * pair.reserveB) / pair.reserveA;\n            }\n            \n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, \"Insufficient B amount\");\n                amountA = amountADesired;\n                amountB = amountBOptimal;\n            } else {\n                if (pair.reserveB > 0) {\n                    amountAOptimal = (amountBDesired * pair.reserveA) / pair.reserveB;\n                }\n                require(amountAOptimal <= amountADesired && amountAOptimal >= amountAMin, \"Insufficient A amount\");\n                amountA = amountAOptimal;\n                amountB = amountBDesired;\n            }\n        }\n        \n        // Calculate liquidity tokens to mint with better precision\n        if (pair.totalLiquidity == 0) {\n            liquidity = Math.sqrt(amountA * amountB) - MINIMUM_LIQUIDITY;\n        } else {\n            uint256 liquidityA = (amountA * pair.totalLiquidity) / pair.reserveA;\n            uint256 liquidityB = (amountB * pair.totalLiquidity) / pair.reserveB;\n            liquidity = Math.min(liquidityA, liquidityB);\n        }\n        \n        require(liquidity > 0, \"Insufficient liquidity minted\");\n        \n        // Transfer tokens from user\n        require(IERC20(pair.tokenA).transferFrom(msg.sender, address(this), amountA), \"Transfer A failed\");\n        require(IERC20(pair.tokenB).transferFrom(msg.sender, address(this), amountB), \"Transfer B failed\");\n        \n        // Update reserves and liquidity\n        pair.reserveA += amountA;\n        pair.reserveB += amountB;\n        pair.totalLiquidity += liquidity;\n        \n        // Update user's liquidity position\n        liquidityPositions[pairId][msg.sender].liquidity += liquidity;\n        liquidityPositions[pairId][msg.sender].timestamp = block.timestamp;\n        \n        emit LiquidityAdded(pairId, msg.sender, amountA, amountB, liquidity);\n    }\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) external nonReentrant whenNotPaused returns (uint256 amountA, uint256 amountB) {\n        bytes32 pairId = getPairId(tokenA, tokenB);\n        require(pairs[pairId].exists, \"Pair does not exist\");\n        require(liquidityPositions[pairId][msg.sender].liquidity >= liquidity, \"Insufficient liquidity\");\n        \n        Pair storage pair = pairs[pairId];\n        \n        // Calculate amounts to return\n        amountA = (liquidity * pair.reserveA) / pair.totalLiquidity;\n        amountB = (liquidity * pair.reserveB) / pair.totalLiquidity;\n        \n        require(amountA >= amountAMin && amountB >= amountBMin, \"Insufficient amounts\");\n        require(amountA > 0 && amountB > 0, \"Insufficient liquidity burned\");\n        \n        // Update liquidity position\n        liquidityPositions[pairId][msg.sender].liquidity -= liquidity;\n        \n        // Update reserves and total liquidity\n        pair.reserveA -= amountA;\n        pair.reserveB -= amountB;\n        pair.totalLiquidity -= liquidity;\n        \n        // Transfer tokens back to user\n        require(IERC20(pair.tokenA).transfer(msg.sender, amountA), \"Transfer A failed\");\n        require(IERC20(pair.tokenB).transfer(msg.sender, amountB), \"Transfer B failed\");\n        \n        emit LiquidityRemoved(pairId, msg.sender, amountA, amountB, liquidity);\n    }\n\n    function swap(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin\n    ) external nonReentrant whenNotPaused returns (uint256 amountOut) {\n        require(amountIn > 0, \"Invalid input amount\");\n        require(tokenIn != tokenOut, \"Identical tokens\");\n        \n        bytes32 pairId = getPairId(tokenIn, tokenOut);\n        require(pairs[pairId].exists, \"Pair does not exist\");\n        \n        Pair storage pair = pairs[pairId];\n        require(pair.reserveA > 0 && pair.reserveB > 0, \"Insufficient liquidity\");\n        \n        // Check user balance\n        require(IERC20(tokenIn).balanceOf(msg.sender) >= amountIn, \"Insufficient balance\");\n        \n        // Determine which token is which\n        bool isTokenAInput = tokenIn == pair.tokenA;\n        (uint256 reserveIn, uint256 reserveOut) = isTokenAInput \n            ? (pair.reserveA, pair.reserveB) \n            : (pair.reserveB, pair.reserveA);\n        \n        // Calculate output amount using constant product formula with overflow protection\n        uint256 amountInWithFee = amountIn * (FEE_DENOMINATOR - tradingFee);\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = (reserveIn * FEE_DENOMINATOR) + amountInWithFee;\n        amountOut = numerator / denominator;\n        \n        require(amountOut >= amountOutMin, \"Insufficient output amount\");\n        require(amountOut < reserveOut, \"Insufficient liquidity\");\n        require(amountOut > 0, \"Zero output amount\");\n        \n        // Transfer tokens\n        require(IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn), \"Transfer in failed\");\n        require(IERC20(tokenOut).transfer(msg.sender, amountOut), \"Transfer out failed\");\n        \n        // Update reserves\n        if (isTokenAInput) {\n            pair.reserveA += amountIn;\n            pair.reserveB -= amountOut;\n        } else {\n            pair.reserveB += amountIn;\n            pair.reserveA -= amountOut;\n        }\n        \n        emit Swap(pairId, msg.sender, tokenIn, tokenOut, amountIn, amountOut);\n    }\n\n    function getAmountOut(\n        uint256 amountIn,\n        address tokenIn,\n        address tokenOut\n    ) external view returns (uint256 amountOut) {\n        require(amountIn > 0, \"Invalid input amount\");\n        \n        bytes32 pairId = getPairId(tokenIn, tokenOut);\n        require(pairs[pairId].exists, \"Pair does not exist\");\n        \n        Pair storage pair = pairs[pairId];\n        bool isTokenAInput = tokenIn == pair.tokenA;\n        (uint256 reserveIn, uint256 reserveOut) = isTokenAInput \n            ? (pair.reserveA, pair.reserveB) \n            : (pair.reserveB, pair.reserveA);\n        \n        require(reserveIn > 0 && reserveOut > 0, \"Insufficient liquidity\");\n        \n        uint256 amountInWithFee = amountIn * (FEE_DENOMINATOR - tradingFee);\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = (reserveIn * FEE_DENOMINATOR) + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    function getPairId(address tokenA, address tokenB) public pure returns (bytes32) {\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        return keccak256(abi.encodePacked(token0, token1));\n    }\n\n    function getPairInfo(address tokenA, address tokenB) external view returns (\n        uint256 reserveA,\n        uint256 reserveB,\n        uint256 totalLiquidity\n    ) {\n        bytes32 pairId = getPairId(tokenA, tokenB);\n        require(pairs[pairId].exists, \"Pair does not exist\");\n        \n        Pair storage pair = pairs[pairId];\n        reserveA = pair.reserveA;\n        reserveB = pair.reserveB;\n        totalLiquidity = pair.totalLiquidity;\n    }\n\n    function getUserLiquidity(address tokenA, address tokenB, address user) external view returns (uint256) {\n        bytes32 pairId = getPairId(tokenA, tokenB);\n        return liquidityPositions[pairId][user].liquidity;\n    }\n\n    function getAllPairs() external view returns (bytes32[] memory) {\n        return pairIds;\n    }\n\n    function setTradingFee(uint256 _fee) external onlyOwner {\n        require(_fee <= MAX_FEE, \"Fee too high\"); // Max 10%\n        uint256 oldFee = tradingFee;\n        tradingFee = _fee;\n        emit TradingFeeUpdated(oldFee, _fee);\n    }\n\n    // Emergency functions\n    function pause() external onlyOwner {\n        paused = true;\n    }\n\n    function unpause() external onlyOwner {\n        paused = false;\n    }\n\n    // Emergency withdrawal function for owner\n    function emergencyWithdraw(address token, uint256 amount) external onlyOwner {\n        require(IERC20(token).transfer(owner(), amount), \"Emergency withdrawal failed\");\n    }\n}",
  "constructorArgs": [],
  "compilerSettings": {
    "version": "0.8.28",
    "settings": {
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "viaIR": true
    }
  },
  "network": "Hyperion Testnet",
  "chainId": 133717,
  "rpcUrl": "https://hyperion-testnet.metisdevops.link",
  "timestamp": "2025-08-02T17:04:24.832Z"
}